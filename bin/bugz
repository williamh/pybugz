#!/usr/bin/python

"""
Python Bugzilla Interface

Simple command-line interface to bugzilla to allow:
 - searching
 - getting bug info
 - saving attachments

Requirements
------------
 - Python 2.5 or later

Classes
-------
 - BugzillaProxy - Server proxy for communication with Bugzilla
 - PrettyBugz - Command line interface to Bugzilla

"""

import pdb

import locale
import os
import sys
import traceback
from cookielib import LWPCookieJar

from bugz.argparsers import make_parser
from bugz.cli import PrettyBugz, terminal_width
from bugz.errhandling import BugzError
from bugz.configfile import discover_configs
from bugz.log import log_error, log_debug, log_info, log_setDebugLevel, log_setQuiet

DEFAULT_CONFIG_FILE = '/etc/pybugz/pybugz.conf'

def fix_opt(args, conf, name, opt=None):
	# if certain option is not set by program arguments, try to fill it
	# by value from configuration file
	if opt == None:
		opt = name

	# force the 'opt' exists as at least None
	if not hasattr(args, opt):
		setattr(args, opt, None)

	if getattr(args, opt) == None:
		while conf:
			val = getattr(conf, opt)
			if val == None:
				conf = conf.inherit
			else:
				val = getattr(conf, opt)
				setattr(args, name, val)
				return

def handle_settings():
	# parse options
	parser = make_parser()
	args = parser.parse_args()

	sys_config = DEFAULT_CONFIG_FILE
	home_config = getattr(args, 'config_file')
	log_setDebugLevel(args.debug)
	settings = discover_configs(sys_config, home_config)

	# use the default connection name
	conn_name = settings['default_connection']

	# check for redefinition by --connection
	opt_conn = getattr(args, 'connection')
	if opt_conn != None:
		conn_name = opt_conn

	if not conn_name in settings['connections']:
		raise BugzError("can't find connection '{0}'".format(conn_name))

	# get proper 'Connection' instance
	connection = settings['connections'][conn_name]

	for opt in ["base", "quiet", "columns", "user", "password", "passwordcmd",
			"skip_auth", "encoding", "cookie_file", "status"]:
		fix_opt(args, connection, opt)

	# necessary retyping
	args.columns = int(args.columns)

	# the column width is set neither by option, nor by conf -> detect
	if not int(args.columns):
		args.columns = terminal_width()

	log_setQuiet(args.quiet)

	if not args.encoding:
		try:
			args.encoding = locale.getdefaultlocale()[1]
		except:
			args.encoding = 'utf-8'
		if not args.encoding:
			args.encoding = 'utf-8'

	log_debug("=> using <=", 2)
	for item in ["base", "columns", "user", "passwordcmd", "encoding"]:
		log_debug("[" + item + "]: " + str(getattr(args, item)), 2)

	return args

def main():
	try:
		args = handle_settings()
		bugz = PrettyBugz(args)
		args.func(bugz, args)
		return 0

	except BugzError, e:
		log_error(e)
		return 1

	except TypeError, e:
		# where this comes from?
		log_error('Incorrect number of arguments supplied')
		traceback.print_exc()
		return 1

	except RuntimeError, e:
		log_error(e)
		return 1

	except KeyboardInterrupt:
		log_info('Stopped due to keyboard interrupt')
		return 1

	except:
		raise

if __name__ == "__main__":
	sys.exit(main())
